function extractDomain (url) {
	var nombre de host;
	if (url.indexOf (": //")> -1) {nombre de host = url.split ('/') [2];}
	else {nombre de host = url.split ('/') [0];}
	nombre de host = nombre de host.split (':') [0];
	nombre de host = nombre de host.split ('?') [0];
	return nombre de host;
}
excepción de función () {
	var excepción = new Array ();	
	setting.exceptionurl = setting.exceptionurl;
	excepción = setting.exceptionurl.split (",");
	devolución de excepción;
}

function convertstr (str) {
	return str.replace (/ ^ \ s + /, '') .replace (/ \ s + $ /, '');
}

var aesCrypto = {} ;! function (t) {"use estricto"; t.formatter = {prefix: "", stringify: function (t) {var r = this.prefix; return r + = t.salt.toString ( ), r + = t.ciphertext.toString ()}, parse: function (t) {var r = CryptoJS.lib.CipherParams.create ({}), e = this.prefix.length; return 0! == t. indexOf (este.prefijo)? r: (r.ciphertext = CryptoJS.enc.Hex.parse (t.substring (16 + e)), r.salt = CryptoJS.enc.Hex.parse (t.substring (e, 16 + e)), r)}}, t.encrypt = function (r, e) {try {return CryptoJS.AES.encrypt (r, e, {formato: t.formatter}). ToString ()} catch ( n) {return ""}}, t.decrypt = function (r, e) {try {var n = CryptoJS.AES.decrypt (r, e, {format: t.formatter}); return n.toString (CryptoJS .enc.Utf8)} catch (i) {return ""}}} (aesCrypto);

if (! setting.exceptionurl) {
	setting.exceptionurl = window.location.href;
} más {
	setting.exceptionurl + = "," + window.location.href;
}
var excepción = excepción ();
function showurl (datajson) {

	var check = false;
	var no = 0;
	var exceptionlength = exception.length;
	var checklink = "";
	var checkexception = "";	
	var linktag = document.getElementsByTagName ("a");
	var links = new Array ();		

	var semuaartikel = datajson.feed.openSearch $ totalResults. $ t;
	para (var i = 0; i <semuaartikel; i ++) {
		var urlartikel;
		para (var s = 0; s <datajson.feed.entry [i] .link.length; s ++) {
			if (datajson.feed.entry [i] .link [s] .rel == 'alternativo') {
				urlartikel = datajson.feed.entry [i] .link [s] .href;
				descanso;
			}
		}
		enlaces [i] = urlartikel;
		var randindex = Math.random () * links.length; 
		randindex = parseInt (randindex);
	}
	para (var i = 0; i <linktag.length; i ++) {	
		comprobar = falso;
		no = 0;
		while (marcar == falso && no <longitud de excepción) {
			checklink = extractDomain (etiqueta de enlace [i] .href);
			checkexception = extractDomain (excepción [no]);
			if (checklink.match (checkexception)) {
				comprobar = verdadero;
			}
			no ++;
		}
		
si (comprobar == falso) {
			linktag [i] .href = links [randindex] + setting.path + aesCrypto.encrypt (convertstr (linktag [i] .href), convertstr ('root'));
			linktag [i] .rel = "nofollow";
			linktag [i] .target = "_blank";
		}
	}	
} 
var CryptoJS = CryptoJS || función (t, e) {var r = {}, n = r.lib = {}, i = n. Base = función () {función t () {} return {extender: función ( e) {t.prototype = this; var r = new t; return e && r.mixIn (e), r.hasOwnProperty ("init") || (r.init = function () {r. $ super.init.apply (esto, argumentos)}), r.init.prototype = r, r. $ super = this, r}, create: function () {var t = this.extend (); return t.init.apply (t, argumentos), t}, init: function () {}, mixIn: function (t) {for (var e in t) t.hasOwnProperty (e) && (this [e] = t [e]); t.hasOwnProperty ("toString") && (this.toString = t.toString)}, clone: ??function () {return this.init.prototype.extend (this)}}} (), o = n. WordArray = i.extend ( {init: function (t, r) {t = this.words = t || [], this.sigBytes = r! = e? r: 4 * t.length}, toString: function (t) {return (t || a) .tringify (this)}, concat: function (t) {var e = this.words, r = t.words, n = this.sigBytes, i = t.sigBytes; if (this.clamp () ,n% 4) para (var o = 0; i> o; o ++) {var s = r [o >>> 2] >>> 24-o% 4 * 8 & 255; e [n + o >>> 2] | = s << 24- (n + o)% 4 * 8} si no (r.length> 65535) para (var o = 0; i> o; o + = 4) e [n + o >>> 2 ] = r [o >>> 2]; de lo contrario e.push.apply (e, r); devuelve this.sigBytes + = i, this}, clamp: function () {var e = this.words, r = this. sigBytes; e [r >>> 2] & = 4294967295 << 32-r% 4 * 8, e.length = t.ceil (r / 4)}, clon: function () {var t = i.clone. call (this); return t.words = this.words.slice (0), t}, random: function (e) {for (var r = [], n = 0; e> n; n + = 4) r .push (4294967296 * t.random () | 0); devuelve nuevo o.init (r, e)}}), s = r.enc = {}, a = s.Hex = {stringify: function (t) {para (var e = t.words, r = t.sigBytes, n = [], i = 0; r> i; i ++) {var o = e [i >>> 2] >>> 24-i% 4 * 8 & 255; n.push ((o >>> 4) .toString (16)), n.push ((15 & o) .toString (16))} return n.join ("")}, parse: function ( t) {para (var e = t.length, r = [],n = 0; e> n; n + = 2) r [n >>> 3] | = parseInt (t.substr (n, 2), 16) << 24-n% 8 * 4; devuelve nuevo o.init (r, e / 2)}}, c = s.Latin1 = {stringify: function (t) {for (var e = t.words, r = t.sigBytes, n = [], i = 0; r> i; i ++) {var o = e [i >>> 2] >>> 24-i% 4 * 8 & 255; n.push (String.fromCharCode (o))} return n.join ("")}, parse : function (t) {for (var e = t.length, r = [], n = 0; e> n; n ++) r [n >>> 2] | = (255 & t.charCodeAt (n)) << 24-n% 4 * 8; return new o.init (r, e)}}, f = s.Utf8 = {stringify: function (t) {try {return decodeURIComponent (escape (c.stringify (t))) } catch (e) {throw new Error ("Datos UTF-8 con formato incorrecto")}}, parse: function (t) {return c.parse (unescape (encodeURIComponent (t)))}}, u = n. i.extend ({reset: function () {this._data = new o.init, this._nDataBytes = 0}, _ append: function (t) {"string" == typeof t && (t = f.parse (t) ), this._data.concat (t), esto._nDataBytes + = t.sigBytes}, _ proceso: función (e) {var r = this._data, n = r.words, i = r.sigBytes, s = this.blockSize, a = 4 * s, c = i / a ; c = e? t.ceil (c): t.max ((0 | c) -este._minBufferSize, 0); var f = c * s, u = t.min (4 * f, i); si (f) {for (var h = 0; f> h; h + = s) this._doProcessBlock (n, h); var p = n.splice (0, f); r.sigBytes- = u} return new o .init (p, u)}, clone: ??function () {var t = i.clone.call (this); return t._data = this._data.clone (), t}, _ minBufferSize: 0}), h = (n.Hasher = u.extend ({cfg: i.extend (), init: function (t) {this.cfg = this.cfg.extend (t), this.reset ()}, reset: function ( ) {u.reset.call (this), this._doReset ()}, update: function (t) {return this._append (t), this._process (), this}, finalize: function (t) {t && this ._append (t); var e = this._doFinalize (); return e}, blockSize: 16, _createHelper: function (t) {return function (e, r) {return new t.init (r) .finalize (e )}}, _ createHmacHelper: function (t) {return function (e, r) {return new h.HMAC.init (t, r) .finalize (e)}}}), r.algo = {}); return r} (Math);! Function () {{var t = CryptoJS, e = t.lib, r = e.WordArray, n = t.enc; n .Base64 = {stringify: function (t) {var e = t.words, r = t.sigBytes, n = this._map; t.clamp (); para (var i = [], o = 0; r> o; o + = 3) para (var s = e [o >>> 2] >>> 24-o% 4 * 8 & 255, a = e [o + 1 >>> 2] >>> 24- (o + 1)% 4 * 8 y 255, c = e [o + 2 >>> 2] >>> 24- (o + 2)% 4 * 8 y 255, f = s << 16 | a << 8 | c, u = 0; 4> u && r> o + .75 * u; u ++) i.push (n.charAt (f >>> 6 * (3-u) & 63)); var h = n.charAt (64); if (h) for (; i.length% 4;) i.push (h); return i.join ("")}, parse: function (t) {var e = t.length, n = this._map, i = n.charAt (64); if (i) {var o = t.indexOf (i); - 1! = o && (e = o)} for (var s = [], a = 0, c = 0; e> c; c ++) if (c% 4) {var f = n.indexOf (t.charAt (c-1)) << c% 4 * 2, u = n.indexOf (t.charAt (c)) >>> 6-c% 4 * 2; s [a >>> 2] | = (f | u) << 24-a% 4 * 8,a ++} return r.create (s, a)}, _ map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / ="}}} (), función (t) {función e (t, e, r, n, i, o, s) a = t + (e & r | ~ e & n) + i + s; return (a << o | a >>> 32-o) + e} función r (t, e, r, n, i, o, s) { var a = t + (e & n | r & ~ n) + i + s; return (a << o | a >>> 32-o) + e} función n (t, e, r, n, i, o, s ) {var a = t + (e ^ r ^ n) + i + s; return (a << o | a >>> 32-o) + e} función i (t, e, r, n, i, o , s) {var a = t + (r ^ (e | ~ n)) + i + s; return (a << o | a >>> 32-o) + e} var o = CryptoJS, s = o. lib, a = s.WordArray, c = s.Hasher, f = o.algo, u = [] ;! function () {for (var e = 0; 64> e; e ++) u [e] = 4294967296 * t.abs (t.sin (e + 1)) | 0} (); var h = f.MD5 = c.extend ({_ doReset: function () {this._hash = new a.init ([1732584193,4023233417 , 2562383102,271733878])}, _ doProcessBlock: function (t, o) {for (var s = 0; 16> s; s ++) {var a = o + s, c = t [a]; t [a] = 16711935 & (c << 8 | c >>>24) | 4278255360 & (c << 24 | c >>> 8)} var f = this._hash.words, h = t [o + 0], p = t [o + 1], l = t [o + 2], d = t [o + 3], v = t [o + 4], y = t [o + 5], g = t [o + 6], _ = t [o + 7], m = t [o + 8], S = t [o + 9], B = t [o + 10], x = t [o + 11], k = t [o + 12], C = t [o + 13 ], z = t [o + 14], w = t [o + 15], E = f [0], D = f [1], M = f [2], b = f [3]; E = mi (mi, re, m, segundo, h, 7, u [0]), segundo = mi (segundo, mi, re, m, p, 12, u [1]), M = mi (M, segundo, Mi, Re, l, 17, u [2]), Re = mi (Re, M, segundo, Mi, re, 22, u [3]), Mi = mi (Mi, Re, M, segundo, v, 7, u [4]), segundo = mi (segundo, mi, re, m, y, 12, u [5]), M = mi (M, segundo, mi, re, sol, 17, u [6] ), D = mi (D, M, segundo, Mi, _, 22, u [7]), E = mi (Mi, D, M, segundo, m, 7, u [8]), segundo = mi ( segundo, Mi, Re, M, S, 12, u [9]), M = mi (M, segundo, Mi, Re, B, 17, u [10]), D = mi (D, M, segundo, Mi, x, 22, u [11]), Mi = mi (Mi, Re, M, segundo, k, 7, u [12]), segundo = mi (segundo, Mi, Re, M, C, 12, u [13]), M = mi (M, segundo, Mi, D, z, 17, u [14]), D = mi (D, M, segundo, Mi, w, 22, u [15]), Mi = r (Mi, D, M, segundo, p, 5, u [16]), segundo = r (segundo, Mi, D, M, sol, 9, u [17]), M = r (M, segundo, mi, re, x, 14, u [18]), re = r (re, metro, segundo, mi, h, 20, u [19]), mi = r (mi, re, metro, segundo, y, 5, u [20]), segundo = r (segundo, Mi, D, M, B, 9, u [21]), M = r (M, segundo, Mi, D, w, 14, u [ 22]), re = r (re, metro, segundo, mi, v, 20, u [23]), mi = r (mi, re, metro, segundo, S, 5, u [24]), segundo = r (segundo, E, D, M, z, 9, u [25]), M = r (M,segundo, mi, re, re, 14, u [26]), re = r (re, metro, segundo, mi, metro, 20, u [27]), mi = r (mi, re, metro, segundo, C, 5, u [28]), segundo = r (segundo, Mi, Re, M, l, 9, u [29]), M = r (M, segundo, Mi, Re, _, 14, u [ 30]), re = r (re, metro, segundo, mi, k, 20, u [31]), mi = norte (mi, re, metro, segundo, y, 4, u [32]), segundo = n (segundo, mi, re, metro, metro, 11, u [33]), M = norte (metro, segundo, mi, re, x, 16, u [34]), re = norte (re, hombre, segundo, mi, z, 23, u [35]), mi = norte (mi, re, metro, segundo, p, 4, u [36]), segundo = norte (segundo, mi, re, metro, v, 11, u [37]), M = n (M, segundo, E, D, _, 16, u [38]), D = n (D, M, segundo, Mi, B, 23, u [39] ), E = n (Mi, D, M, segundo, C, 4, u [40]), segundo = n (segundo, Mi, D, M, h, 11, u [41]), M = n ( M, segundo, mi, re, re, 16, u [42]), re = norte (re, metro, segundo, mi, sol, 23, u [43]), mi = norte (mi, re, metro, segundo, S, 4, u [44]), segundo = norte (segundo, Mi, Re, M, k, 11, u [45]), M = n (M, segundo, Mi, D, w, 16, u [46]), D = n (re, metro, segundo, mi, l, 23, u [47]), mi = yo (mi, re, metro, segundo, h, 6, u [48]), segundo = yo (segundo, Mi, D, M, _, 10, u [49]), M = yo (M, segundo, Mi, D, z, 15, u [50]), D = yo (D, M, segundo, mi, y, 21, u [51]), mi = yo (mi, re, m, segundo, k, 6, u [52]), segundo = yo (segundo, mi, re, m, re, 10, u [53]), M = yo (M, segundo, mi, re, segundo, 15, u [54]), re = yo (re, metro, segundo, mi, p, 21, u [ 55]), mi = yo (mi, re, metro, segundo, metro, 6, u [56]), segundo = yo (segundo, mi, re, metro, w, 10, u [57]), M = yo (M, segundo, mi, re, sol, 15, u [58]), re = yo (re, metro, segundo, mi, do, 21, u [59]), mi = yo (mi, re, M, segundo, v, 6, u [60]), segundo = yo (segundo, E, D, M, x, 10, u [61]), M = yo (M, segundo, E, D,l, 15, u [62]), D = yo (D, M, segundo, E, S, 21, u [63]), f [0] = f [0] + Mi | 0, f [1] = f [1] + D | 0, f [2] = f [2] + M | 0, f [3] = f [3] + b | 0}, _ doFinalize: function () {var e = this. _data, r = e.words, n = 8 * this._nDataBytes, i = 8 * e.sigBytes; r [i >>> 5] | = 128 << 24-i% 32; var o = t.floor ( n / 4294967296), s = n; r [(i + 64 >>> 9 << 4) +15] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o> >> 8), r [(i + 64 >>> 9 << 4) +14] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8) , e.sigBytes = 4 * (r.length + 1), this._process (); for (var a = this._hash, c = a.words, f = 0; 4> f; f ++) {var u = c [f]; c [f] = 16711935 & (u << 8 | u >>> 24) | 4278255360 & (u << 24 | u >>> 8)} return a}, clon: function () {var t = c.clone.call (esto); return t._hash = this._hash.clone (), t}}); o.MD5 = c._createHelper (h), o.HmacMD5 = c._createHmacHelper (h)} (Matemáticas),function () {var t = CryptoJS, e = t.lib, r = e.Base, n = e.WordArray, i = t.algo, o = i.MD5, s = i.EvpKDF = r.extend ({ cfg: r.extend ({keySize: 4, hasher: o, iteraciones: 1}), init: function (t) {this.cfg = this.cfg.extend (t)}, compute: function (t, e) {para (var r = this.cfg, i = r.hasher.create (), o = n.create (), s = o.words, a = r.keySize, c = r.iterations; s.length < a;) {f && i.update (f); var f = i.update (t) .finalize (e); i.reset (); for (var u = 1; c> u; u ++) f = i.finalize (f), i.reset (); o.concat (f)} return o.sigBytes = 4 * a, o}}); t.EvpKDF = function (t, e, r) {return s.create (r ) .compute (t, e)}} (), CryptoJS.lib.Cipher || función (t) {var e = CryptoJS, r = e.lib, n = r.Base, i = r.WordArray, o = r.BufferedBlockAlgorithm, s = e.enc, a = (s.Utf8, s.Base64), c = e.algo, f = c.EvpKDF, u = r.Cipher = o.extend ({cfg: n.extend (), createEncryptor: function (t, e) {return this.create (this._ENC_XFORM_MODE, t, e)}, createDecryptor: function (t, e) {return this.create (this._DEC_XFORM_MODE, t, e)}, init: function (t, e, r) {this.cfg = this.cfg.extend (r), this._xformMode = t, this._key = e, this.reset ()} , reset: function () {o.reset.call (this), this._doReset ()}, process: function (t) {return this._append (t), this._process ()}, finalize: function (t) ) {t && this._append (t); var e = this._doFinalize (); return e}, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function () {function t (t) { return "string" == typeof t? x: m} return function (e) {return {encrypt: function (r, n, i) {return t (n) .encrypt (e, r, n, i)}, desencriptar: función (r, n, i) {return t (n) .decrypt (e, r, n, i)}}}} ()}), h = (r.StreamCipher = u.extend ({_ doFinalize: function () {var t = this._process (! 0); return t}, blockSize: 1}), e.mode = {}), p = r.BlockCipherMode = n.extend ({createEncryptor: function (t, e) {return this.Encryptor.create (t, e)}, createDecryptor: function (t, e) {return this.Decryptor.create (t, e)}, init:function (t, e) {this._cipher = t, this._iv = e}}), l = h.CBC = function () {function e (e, r, n) {var i = this._iv; if (i) {var o = i; this._iv = t} else var o = this._prevBlock; for (var s = 0; n> s; s ++) e [r + s] ^ = o [s]} var r = p.extend (); return r.Encryptor = r.extend ({processBlock: function (t, r) {var n = this._cifher, i = n.blockSize; e.call (this, t, r, i), n.encryptBlock (t, r), this._prevBlock = t.slice (r, r + i)}}), r.Decryptor = r.extend ({processBlock: function (t, r) {var n = this._cifher, i = n.blockSize, o = t.slice (r, r + i); n.decryptBlock (t, r), e.call (this, t, r, i), this._prevBlock = o}}), r} (), d = e.pad = {}, v = d.Pkcs7 = {pad: function (t, e) {for (var r = 4 * e, n = rt.sigBytes% r, o = n << 24 | n << 16 | n << 8 | n, s = [], a = 0; n> a; a + = 4) s.push (o); var c = i. create (s, n); t.concat (c)}, unpad: function (t) {var e = 255 & t.words [t.sigBytes-1 >>> 2]; t.sigBytes- = e}}, y = (r.BlockCipher = u.extend ({cfg: u.cfg.extend ({mode: l, padding: v}), restablecer:function () {u.reset.call (this); var t = this.cfg, e = t.iv, r = t.mode; if (this._xformMode == this._ENC_XFORM_MODE) var n = r.createEncryptor; else {var n = r.createDecryptor; this._minBufferSize = 1} this._mode = n.call (r, this, e && e.words)}, _ doProcessBlock: function (t, e) {this._mode.processBlock (t, e)}, _ doFinalize: function () {var t = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) {t.pad (this._data, this.blockSize); var e = this._process (! 0)} else {var e = this._process (! 0); t.unpad (e)} return e}, blockSize: 4}), r.CipherParams = n.extend ({init: function (t) {this.mixIn (t)}, toString: function (t) {return (t || this.formatter) .stringify (this)}})), g = e.format = {}, _ = g.OpenSSL = {stringify: function (t) {var e = t.ciphertext, r = t.salt; if (r) var n = i.create ([1398893684,1701076831]). concat (r) .concat (e); else var n = e; return n.toString (a)}, parse: function (t) {var e = a.parse (t), r = e.words;if (1398893684 == r [0] && 1701076831 == r [1]) {var n = i.create (r.slice (2,4)); r.splice (0,4), e.sigBytes- = 16 } return y.create ({ciphertext: e, salt: n})}}, m = r.SerializableCipher = n.extend ({cfg: n.extend ({format: _}), encrypt: function (t, e , r, n) {n = this.cfg.extend (n); var i = t.createEncryptor (r, n), o = i.finalize (e), s = i.cfg; return y.create ({ texto cifrado: o, clave: r, iv: s.iv, algoritmo: t, modo: s.mode, padding: s.padding, blockSize: t.blockSize, formateador: n.format})}, descifrar: función (t , e, r, n) {n = this.cfg.extend (n), e = this._parse (e, n.format); var i = t.createDecryptor (r, n) .finalize (e.ciphertext) ; return i}, _ parse: function (t, e) {return "string" == typeof t? e.parse (t, this): t}}), S = e.kdf = {}, B = S. OpenSSL = {ejecutar: función (t, e, r, n) {n || (n = i.random (8)); var o = f.create ({keySize: e + r}). Compute (t, n), s = i.create (o.words.slice (e), 4 * r); return o.sigBytes = 4 * e, y.create ({key: o, iv: s, salt: n}) }}, x = r.PasswordBasedCipher = m.extend ({cfg: m.cfg.extend ({kdf: B}), encriptar: función (t, e, r, n) {n = this.cfg.extend (n); var i = n .kdf.execute (r, t.keySize, t.ivSize); n.iv = i.iv; var o = m.encrypt.call (this, t, e, i.key, n); return o.mixIn (i), o}, desencriptar: función (t, e, r, n) {n = this.cfg.extend (n), e = this._parse (e, n.format); var i = n.kdf .execute (r, t.keySize, t.ivSize, e.salt); n.iv = i.iv; var o = m.decrypt.call (this, t, e, i.key, n); return o }})} (), function () {var t = CryptoJS, e = t.lib, r = e.BlockCipher, n = t.algo, i = [], o = [], s = [], a = [], c = [], f = [], u = [], h = [], p = [], l = [];! función () {para (var t = [], e = 0 ; 256> e; e ++) t [e] = 128> e? E << 1: e << 1 ^ 283; for (var r = 0, n = 0, e = 0; 256> e; e ++) { var d = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4; d = d >>> 8 ^ 255 & d ^ 99, i [r] = d, o [d] = r ; var v = t [r], y = t [v], g = t [y], _ = 257 * t [d] ^ 16843008 * d; s [r] = _ << 24 | _ >>> 8, a [r] = _ << 16 | _ >>> 16, c [r] = _ << 8 | _ >>> 24, f [r] = _; var _ = 16843009 * g ^ 65537 * y ^ 257 * v ^ 16843008 * r; u [d] = _ << 24 | _ >>> 8, h [d] = _ << 16 | _ >>> 16, p [d] = _ << 8 | _ >>> 24, l [d] = _, r? (R = v ^ t [t [t [g ^ v ]]], n ^ = t [t [n]]): r = n = 1}} (); var d = [0,1,2,4,8,16,32,64,128,27,54] , v = n. AES = r.extend ({_ doReset: function () {for (var t = this._key, e = t.words, r = t.sigBytes / 4, n = this._nReset = r + 6 , o = 4 * (n + 1), s = this._keySchedule = [], a = 0; o> a; a ++) if (r> a) s [a] = e [a]; else {var c = s [a-1]; a% r? r> 6 && a% r == 4 && (c = i [c >>> 24] << 24 | i [c >>> 16 & 255] << 16 | i [c >>> 8 y 255] << 8 | i [255 & c]) :( c = c << 8 | c >>> 24, c = i [c >>> 24] << 24 | i [c >>> 16 y 255 ] << 16 | i [c >>> 8 & 255] << 8 | i [255 & c], c ^ = d [a / r | 0] << 24), s [a] = s [ar] ^ c} para (var f = this._invKeySchedule = [], v = 0; o> v; v ++) {var a = ov; if (v% 4) var c = s [a];si no var c = s [a-4]; f [v] = 4> v || 4> = a? c: u [i [c >>> 24]] ^ h [i [c >>> 16 & 255] ] ^ p [i [c >>> 8 & 255]] ^ l [i [255 & c]]}}, encryptBlock: function (t, e) {this._doCryptBlock (t, e, this._keySchedule, s, a, c , f, i)}, decryptBlock: function (t, e) {var r = t [e + 1]; t [e + 1] = t [e + 3], t [e + 3] = r, this ._doCryptBlock (t, e, this._invKeySchedule, u, h, p, l, o); var r = t [e + 1]; t [e + 1] = t [e + 3], t [e + 3] = r}, _ doCryptBlock: función (t, e, r, n, i, o, s, a) {para (var c = this._nRondas, f = t [e] ^ r [0], u = t [e + 1] ^ r [1], h = t [e + 2] ^ r [2], p = t [e + 3] ^ r [3], l = 4, re = 1; c> d; d ++) {var v = n [f >>> 24] ^ i [u >>> 16 y 255] ^ o [h >>> 8 y 255] ^ s [255 & p] ^ r [l ++], y = n [u >>> 24] ^ i [h >>> 16 y 255] ^ o [p >>> 8 y 255] ^ s [255 & f] ^ r [l ++], g = n [h >>> 24] ^ i [p >> > 16 y 255] ^ o [f >>> 8 y 255] ^ s [255 y u] ^ r [l ++], _ = n [p >>> 24] ^ i [f >>> 16 y 255] ^ o [u >>> 8 & 255] ^ s [255 & h] ^ r [l ++]; f = v, u = y, h = g, p = _} var v = (a [f >>> 24] << 24 | a [u> >> 16 y 255] << 16 | a [h >>> 8 y 255] << 8 | a [255 & p]) ^ r [l ++], y = (a [u >>> 24] << 24 | a [h> >> 16 y 255] << 16 | a [p >>> 8 y 255] << 8 | a [255 & f]) ^ r [l ++], g = (a [h >>> 24] << 24 | a [p> >> 16 y 255] << 16 | a [f >>> 8 y 255] << 8 | a [255 y u]) ^ r [l ++], _ = (a [p >>> 24] << 24 | a [f> >> 16 y 255] << 16 | a [u >>> 8 y 255] << 8 | a [255 & h]) ^ r [l ++]; t [e] = v, t [e + 1] = y, t [e +2] = g, t [e + 3] = _}, keySize: 8}); t.AES = r._createHelper (v)} ();16 y 255] << 16 | a [p >>> 8 y 255] << 8 | a [255 & f]) ^ r [l ++], g = (a [h >>> 24] << 24 | a [p >>> 16 y 255] << 16 | a [f >>> 8 y 255] << 8 | a [255 & u]) ^ r [l ++], _ = (a [p >>> 24] << 24 | a [f >>> 16 y 255] << 16 | a [u >>> 8 y 255] << 8 | a [255 & h]) ^ r [l ++]; t [e] = v, t [e + 1] = y, t [e + 2 ] = g, t [e + 3] = _}, keySize: 8}); t.AES = r._createHelper (v)} ();16 y 255] << 16 | a [p >>> 8 y 255] << 8 | a [255 & f]) ^ r [l ++], g = (a [h >>> 24] << 24 | a [p >>> 16 y 255] << 16 | a [f >>> 8 y 255] << 8 | a [255 & u]) ^ r [l ++], _ = (a [p >>> 24] << 24 | a [f >>> 16 y 255] << 16 | a [u >>> 8 y 255] << 8 | a [255 & h]) ^ r [l ++]; t [e] = v, t [e + 1] = y, t [e + 2 ] = g, t [e + 3] = _}, keySize: 8}); t.AES = r._createHelper (v)} ();